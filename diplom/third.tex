% -*- mode: LaTeX; mode: auto-fill; mode: flyspell; coding: koi8-r; -*-
\chapter{Реализация динамических функций}

Как мы увидели из предыдущей главы, готовых решений для создания
динамических функций нет. Давайте более подробно рассмотрим решение
построенное на основе библиотеки Dynamic: Функция от двух аргументов,
диспетчеризующая типы Integer и Double может быть определена следующим
образом:

\begin{code}
func :: [Dynamic] -> Maybe Dynamic
func [a1,a2] | (dynTypeRep a1 == typeOf (undefined :: Integer))
               && (dynTypeRep a2 == typeOf (undefined :: Integer))
	     = (fromDynamic a1 :: Maybe Integer) >>= \a1 ->
	       (fromDynamic a2 :: Maybe Integer) >>= \a2 ->
	       Just $ toDyn $ function a1 a2
             | (dynTypeRep a1 == typeOf (undefined :: Double))
               && (dynTypeRep a2 == typeOf (undefined :: Double))
	     = (fromDynamic a1 :: Maybe Double) >>= \a1 ->
	       (fromDynamic a2 :: Maybe Double) >>= \a2 ->
	       Just $ toDyn $ function a1 a2
	     | otherwise = Nothing
func _ = Nothing
\end{code}	       

Данная функция потребует определения следующих таблиц:

\begin{code}
symbolTable = [("func", func)]
readTable = [("Integer", toDyn . (read :: String -> Integer)),
             ("Double", toDyn . (read :: String -> Double))]
showTable = [(typeOf (undefined :: Integer),
              \a -> (fromDynamic a :: Maybe Integer) >>= Just . show),
	     (typeOf (undefined :: Double),
              \a -> (fromDynamic a :: Maybe Double) >>= Just . show)]
\end{code}

Программисту, как легко понять из данного кода, приходится писать
очень много служебного кода необходимого для обеспечения корректности
типов при исполнении. Данную неприятность можно решить создав DSL из которого будет
генерироваться служебный код.

\section{DSEL на Template Haskell}
Как было сказано выше Template Haskell позволяет генерировать
корректный код на Hskell во время компиляции, а следовательно при
использовании данного расширения мы получаем возможность генерировать
части определения функции. Давайте выделим основные части определения
функции

\begin{code}
func [a1,a2] | $(typeTest [| a1 |] [t| Integer |])
               && $(typeTest [| a1 |] [t| Integer |])
	     = $(extractArg [| a1 |] [t| Integer |]) >>= \a1 ->
	       $(extractArg [| a2 |] [t| Integer |]) >>= \a2 ->
	       $(packResult [| function a1 a2 |])
\end{code} %$

В представленном выше коде \$( ... ) это специальный синтаксис
определенный расширением Template Haskell для вызова функций во время
компиляции. Синтаксис [| code |] и [t| type |] также определён
расширением Template Haskell и возвращает дерево разбора для кода
``code'' и типа ``type'' соответственно.

Наборы функций typeTest достаточно легко заменить на одну функцию,
принимающую список пар (Аргумент, Тип):

\begin{code}
$(typeTest [
    ([| a1 |], [t| Integer |]),
    ([| a2 |], [t| Integer |])
])
\end{code} %$

Немного более сложно заменить последовательность функций extractArg
заканчивающуюся функцией packResult в качестве одной функции. Для
определения такого ряда в виде

\begin{code}
$(extractAndEval [([| a1 |], [t| Integer |]),
                   ([| a2 |], [t| Integer |])]
                 [| function a1 a2 |])
\end{code} %$
необходимо произвести обход абстрактного синтаксического дерева
представляющего код <<function a1 a2>> и заменить переменные a1 и a2 на
переменные требуемых типов. Такая потребность возникает из-за того,
что синтаксические области видимости разделяются в момент
синтаксического разбора, а не после генерации синтаксических
деревьев. Это легко проследить на следующем примере

\begin{code}
runQ [| \a -> \a -> a |]
==> LamE [VarP a_2] (LamE [VarP a_3] (VarE a_3))
\end{code}
В этом примере переменная a внешней лямбда функции получила имя a\_2, а
переменная a внутренней лямбда функции получила имя a\_3.

Собрав воедино предложенные функции и использовав дополнительный
синтаксис <<'var>>\cite{th2} возвращающий имя переменной <<var>> можно
определить динамическую в следующем виде:

\begin{code}
func :: [Dynamic] -> Maybe Dynamic
func [a, b] = $(typesAndExecutesN [
                   ([('a, [t| Integer |]),
                     ('b, [t| Integer |])],
                    [| function a b |]),
                   
                   ([('a, [t| Double |]),
                     ('b, [t| Double |])],
                    [| function a b |])
                ])
func _ = Nothing

genSymbolTable [("func", [| func |])]
genReadShowTable [
  ([t| Integer |], "Integer", [| read |], [| show |]),
  ([t| Double |], "Double",  [| read |], [| show |])
  ]
\end{code} %$

К сожалению, так как GHC проводит проверку типов как до запуска Template Haskell
так и после, если функция function не является полиморфной функцией, то
первая проверка типов, ожидающая увидеть тип функции

\begin{code}
function :: Dynamic -> Dynamic -> a
\end{code}
будет сигнализировать об ошибке. В качестве варианта решения данной
проблемы можно использовать unsafe преобразование и записать вызов
функции в виде

\begin{code}
[| (unsafeCoerce function :: (a -> b -> c)) a b |]
\end{code}

Такое решение вносит дополнительное место в котором может произойти
ошибка типов, которую позже будет крайне сложно обнаружить.

\section{DSL реализованный внешней программой}

В качестве внешнего языка из которого генерируется код Dynamic функций
мной был предложен и реализован при помощи библиотеки
Parsec\cite{parsec} язык следующего вида:

\begin{code}
Integer func (Integer a, Integer b)
Double func (Double a, Double b)
{
  function a b
}

Double func (Double a, Integer b)
Double func (Integer b, Double a)
{
  function a b
}

typedef readTypes = [Integer, Double];

readTypes read (String s) { read s }
String show (readTypes a) { show a }
\end{code}

Этот язык предоставляет следующие возможности:

\begin{enumerate}
\item Для одного и того же тела функции можно указать несколько
  наборов типов аргументов, что позволяет удобно определять возможные
  типы полиморфных функций.
\item Имена аргументов в разных определениях можно менять местами, что
  позволяет описывать функции с переставленными аргументами.
\item Оператор typedef позволяет указывать списки типов. При
  использовании такого списка в определении -- определение развернётся
  в ряд определений, в каждом из которых будет подставлен один из
  типов указанных в списке.
\end{enumerate}

%% \section{DSEL с использованием Quasi Quotation}

%% Расширение языка Haskell под названием Quasi Quotation позволяет
%% определять кодогенераторы работающие во время компиляции в виде
%% \begin{code}
%% [$parser| mani lines
%%   code that describe
%%   somthing interesting |]
%% \end{code} %$
%% Код внутри блока [\$parser|~\ldots~|] передаётся парсеру как строка. На
%% вывод парсер должен вернуть корректное, с точки зрения компилятора,
%% синтаксическое дерево. Данное расширение удобно использовать для
%% генерации объектов сложного типа, но крайне сложно использовать для
%% генерации Haskell программы, поскольку для этого придётся реализовать
%% полностью разбор и генерацию синтаксических деревьев, что является
%% достаточно трудоёмкой задачей. 

\section{Сравнение двух реализаций}

Главным преимуществом реализации на Template Haskell является низкая
стоимость изменения или дополнения функционала, но это достигается
ценой ясности синтаксиса, необходимостью явного определения таблицы
символов и таблиц функций ввода и вывода, а также проблемой при
описании не полиморфных функций.

В отличие от реализации на Template Haskell, в которой функционал
можно менять простым добавлением функций генерирующих новые виды
блоков кода, для изменения языка реализованного отдельным
кодорегератором необходимо изменение грамматики используемой для
разбора языка, а также модификация функций генерирующих код на основе
полученного синтаксического дерева.

Среди преимуществ использования внешнего кодогенератора стоит отметить
более простую отладку связанную с тем, что в случае ошибки в теле
функции используемые переменные будут иметь те же имена что дал им
программист. Кроме того отсутствие проверки типов до полной генерации
кода позволяет отказаться от unsafe преобразований в коде программиста.

\section{Библиотека для использования динамических функций}

Для совместного использования набора динамических функций также
необходимо иметь библиотеку реализующую логику их взаимодействия.

Была разработана библиотека предоставляющая ряд интерфейсов.

\begin{enumerate}
\item Функции для объединения нескольких динамических функций и
  нескольких таблиц данных.

\begin{code}
dplus :: DFunction -> DFunction -> DFunction
stplus :: SymbolTable -> SymbolTable -> SymbolTable
rtplus :: ReadTable -> ReadTable -> ReadTable
shtplus :: ShowTable -> ShowTable -> ShowTable
\end{code}
\item Функции для взаимодействия с таблицами данных

\begin{code}
getFun :: SymbolTable -> String -> Maybe DFunction
getRead :: ReadTable -> String -> Maybe (String -> Dynamic)
argToDyn :: ReadTable -> Argument -> Maybe Dynamic
getShow :: ShowTable -> Dynamic -> Maybe String
\end{code}
\item А также функции используемые для разбора и выполнения ввода пользователя

\begin{code}
parseString :: String -> Maybe Function
eval :: SymbolTable -> ReadTable -> Function -> Maybe Dynamic
\end{code}
\end{enumerate}

Кроме того создана функция реализующая полностью REPL

\begin{code}
data ProgramData =
  PD { readInput :: IO String,
       symbolTable :: SymbolTable,
       readTable :: ReadTable,
       showTable :: ShowTable,
       importModules :: [(String, (SymbolTable, ReadTable, ShowTable))]
     }

repl :: ProgramData -> IO ()
\end{code}
Данная функция получает набор данных который включает в себя функцию
для считывания ввода пользователя, таблицы данных используемых по
умолчанию и список модулей, которые можно подключить во время работы
REPL.

Таким образом предоставлены простые интерфейсы для совместного
использования динамических функций. 

Рассмотрим как будет выглядеть главный модуль:

\begin{code}
import DynamicFace
import qualified DefaultModule as D
import qualified Module1 as M1
import qualified Module2 as M2

main = repl $ PD D.symbolTable, D.readTable, D.showTable
                 [("M1", (M1.symbolTable, M1.readTable, M1.showTable)),
                  ("M2", (M2.symbolTable, M2.readTable, M2.showTable))]
\end{code} %$

В данном примере можно увидеть ещё одну проблему предложенного
решения: При создании нового модуля необходимо добавление этого
модуля в main функцию для того, чтобы пользователь мог получить доступ
к функционалу модуля через REPL. 

Данная проблема легко решается при помощи программы, обходящей все
файлы с исходным кодом и генерирующей Main модуль, подключающий все
найденные динамические библиотеки.

\section{Пример использования}

Рассмотрим пример программы использующей предложенные решения:

Создадим файл ``Math.gen'' со следующим содержанием

\begin{code}
module Math (
       symbolTable,
       readTable,
       showTable
       ) where

import qualified Complex as C
%%
type Complex = C.Complex Double;

Complex plus (Complex a, Complex b)
Double plus (Double a, Double b)
{
  a + b
}

Complex minus (Complex a, Complex b)
Double minus (Double a, Double b)
{
  a - b
}

Complex root (Complex a)
Double root (Double a) when { a >= 0 }
{
  sqrt a
}

Complex root (Double a) when { a < 0 }
{
  0 C.:+ (sqrt (-a))
}

typedef readTypes = [Complex, Double];

readTypes read (String s) { read s }
String show (readTypes a) { show a }
\end{code}

Данный файл содержит дополнительный синтаксис не описанный ранее. Весь
текст до строки ``\%\%'' при генерации модуля Haskell вставляется в
результирующий файл без изменения. Команда ``type Type = Other Type;''
транслируются в аналогичную команду языка Haskell и необходима для
создания более простых в написании имён типов. Кроме того появился
блок ``when'' который используется для указания ограничений на
переменные отличных от их типа.

После генерации кода мы получим файл ``Math.hs'' реализующий
динамический модуль Math. Теперь мы можем сгенерировать модуль Main.hs
при помощи программ ищущей динамические модули. Автоматически
сгенерированный модуль будет выглядеть следующим образом

\begin{code}
import DynamicFace
import qualified Math
main = repl $ defaultPD {
  importModules = [("Math", (Math.symbolTable, Math.readTable, Math.showTable))]
  }
\end{code} %$

В данном коде можно увидеть также неописанный дальше элемент. Объект
типа ProgramData создаётся на основе существующего в библиотеке
объекта defaultPD, устанавливающего в качестве функции ввода функцию
readLine языка Haskell, при помощи замены поля importModules данного
объекта.

Программу получившуюся при компиляции данного кода можно использовать
следующим образом:

\begin{code}
$ ./Main 
import Math
==> imported
plus 1.0 2.0
==> (3.0 :: Double)
root 1.0
==> (1.0 :: Double)
root -9.0
==> (0.0 :+ 3.0 :: Complex)
plus (0.0 :+ 3.0 :: Complex) (3.2 :+ 3.0 :: Complex)
==> (3.2 :+ 6.0 :: Complex)
quit
$ 
\end{code}

В предложенном примере в первой строчке после запуска программы мы
подключили модуль Math. После этого пример использования нескольких
функций. Как видно из этого примера библиотечная функция parseString
умеет разбирать тип Double без подсказки. Также реализован разбор типа
Integer. Для остальных типов при вводе необходима подсказка, то есть
данные надо вводить в виде

\begin{code}
(string represenation :: Type Identifier)
\end{code}
