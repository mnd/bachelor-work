\chapter{}

Как мы увидели из предыдущей главы готовых решений для создания
динамических функций нет. Давайте более подробно рассмотрим решение
построенное на типе Dynamic: Функция от двух аргументов,
диспетчеризующая типы Integer и Double может быть определена следующим
образом:

\begin{code}
func :: [Dynamic] -> Maybe Dynamic
func [a1,a2] | (dynTypeRep a1 == typeOf (undefined :: Integer))
               && (dynTypeRep a2 == typeOf (undefined :: Integer))
	     = (fromDynamic a1 :: Maybe Integer) >>= \a1 ->
	       (fromDynamic a2 :: Maybe Integer) >>= \a2 ->
	       Just $ toDyn $ function a1 a2
             | (dynTypeRep a1 == typeOf (undefined :: Double))
               && (dynTypeRep a2 == typeOf (undefined :: Double))
	     = (fromDynamic a1 :: Maybe Double) >>= \a1 ->
	       (fromDynamic a2 :: Maybe Double) >>= \a2 ->
	       Just $ toDyn $ function a1 a2
	     | otherwise = Nothing
func _ = Nothing
\end{code}	       

И данная функция потребует следующих таблиц:

\begin{code}
symbolTable = [("func", func)]
readTable = [("Integer", toDyn . (read :: String -> Integer)),
             ("Double", toDyn . (read :: String -> Double))]
showTable = [(typeOf (undefined :: Integer),
              \a -> (fromDynamic a :: Maybe Integer) >>= Just . show),
	     (typeOf (undefined :: Double),
              \a -> (fromDynamic a :: Maybe Double) >>= Just . show)]
\end{code}

Программисту, как легко понять из данного кода, приходится писать
очень много служебного кода, и, вопреки приятому в среде программистов
правилу Dont't Repeat Yourself, по нескольку раз писать тип каждого
аргумента.

Данную неприятность можно решить создав DSL из которого будет
генерироваться служебный код.

\section{DSEL на Template Haskell}
Как было сказано выше Template Haskell позволяет генерировать
корректный код на Hskell во время компиляции, а следовательно при
использовании данного расшрения мы получаем возможность генерировать
части определениф функции. Давайте выделим основные части определения
функции

\begin{code}
func [a1,a2] | $(typeTest [| a1 |] [t| Integer |])
               && $(typeTest [| a1 |] [t| Integer |])
	     = $(extractArg [| a1 |] [t| Integer |]) >>= \a1 ->
	       $(extractArg [| a2 |] [t| Integer |]) >>= \a2 ->
	       $(packResult [| function a1 a2 |])
\end{code} %$


В представленном выше коде \$( ... ) это специальный синтаксис
определенный расширением Template Haskell для вызова функций во время
компиляции. Синтаксис [| code |] и [t| type |] также определён
расширением Template Haskell и возвращает дерево разбора для кода
'code' и типа 'type' соответственно.

Наборы функций typeTest достаточно легко заменить на одну функцию,
принимающую список пар (Аргемент, Тип):

\begin{code}
  $(typeTest [
      ([| a1 |], [t| Integer |]),
      ([| a2 |], [t| Integer |])
  ])
\end{code} %$
Немного более сложно возможно заменить последовательность функций
extractArg заканчивающуюся функцией packResult в качестве одной
функци. Для определения такого ряда в виде

\begin{code}
  $(extractAndEval [([| a1 |], [t| Integer |]),
                     ([| a2 |], [t| Integer |])]
                   [| function a1 a2 |])
\end{code} %$

необходимо произвести обход AST представляющего код "function a1 a2" и
заменить переменные a1 и a2 на сгенерированные дополнительно. Такая
потребность возникает из-за того, что синтаксические области видимости
разделяются в момент синтаксического разбора, а не после генерации
деревьев. Это легко проследить на следующем примере

\begin{code}
runQ [| \a -> \a -> a |]
==> LamE [VarP a_2] (LamE [VarP a_3] (VarE a_3))
\end{code}

В этом примере переменная a внешней лямбда функции получила имя a\_2, а
переменная a внутренней лямбда функции получила имя a\_3.

Таким образом решение в окончательном виде, при использовании ещё
одного дополнительного синтаксиса 'var возвращающего имя переменной
var, может выглядеть следующим образом

\begin{code}
func :: [Dynamic] -> Maybe Dynamic
func [a, b] = $(typesAndExecutesN [
                   ([('a, [t| Integer |]),
                     ('b, [t| Integer |])],
                    [| function a b |]),
                   
                   ([('a, [t| Double |]),
                     ('b, [t| Double |])],
                    [| function a b |])
                ])
func _ = Nothing

genSymbolTable [("func", [| func |])]
genReadShowTable [
  ([t| Integer |], "Integer", [| read |], [| show |]),
  ([t| Double |], "Double",  [| read |], [| show |])
  ]
\end{code} %$

Но в данном решении есть одна проблема:

Так как GHC проводит проверку типов как до запуска Template Haskell
так и после, то если функция function реализована не полиморфно, то
первая проверка типа не проидет. В качестве work around можно
предложить следующий вариант

\begin{code}
  [| (unsafeCoerce function :: (a -> a -> a)) a b |]
\end{code}

Который вносит дополнительное место в котором может произойти
неотлавливаемая ошибка типов.

\section{DSL реализованный внешним парсером}

В качестве внешнего языка из которого генерируется код Dynamic функций
мной был предложен язык следующего вида:

Integer func (Integer a, Integer b)
Double func (Double a, Double b)
{
  function a b
}

\begin{code}
  Double func (Double a, Integer b)
  Double func (Integer b, Double a)
  {
    function a b
  }

  typedef readTypes = [Integer, Double];

  readTypes read (String s) { read s }
  String show (readTypes a) { show a }
\end{code}

Этот язык предоставляет следующие возможности:

1. Для одного и того же тела функции можно указать несколько наборов
   типов аргументов, что удобно для полиморфных функций.
2. Имена аргументов в разных определениях можно менять местами, что
   позволяет описывать симметричные функции.
3. Оператор typedef позволяет указывать списки типов. При
   использовании такого списка в определении -- определение
   развернётся в ряд определений, в каждом из которых будет подставлен
   один из типов указанных в списке.

\section{DSEL с использованием Quasi Quotation или почему я не стал его
реализовывать}

Расширение языка Haskell под названием Quasi Quotation позволяет
определять кодогенераторы работающие во время компиляции в виде

\begin{code}
  [$parser| mani lines
    code that describe
    somthing interesting |]
\end{code} %$
Код внутри блока [\$parser| ... |] передаётся парсеру как строка. На
вывод парсер должен вернуть корректное с точки зрения компилятора
синтаксическое дерево. Данное расширение удобно использовать для
генерации объектов сложного типа, но крайне сложно использовать для
генерации Haskell программы, поскольку для этого придётся реализовать
полностью разбор и генерацию синтаксических деревьев, что является
достаточно трудоёмкой задачей. 

\section{Сравнение двух реализаций}

Главным приемуществом реализации на Template Haskell является низкая
стоимость изменения или дополнения функционала, но это достигается
ценой ясности синтаксиса, необходимостью явного определения таблицы
символов и таблиц функций ввода и вывода, а также проблемой при
описании не полиморфных функций.

Реализация внешнего парсера менее переносима: для его использования не
достаточно иметь установленный ghc в системе, но также необходимо
иметь скомпилированный кодогенератор. Данная проблема может быть
минимизирована при реализации кодогенератора на языке Haskell. 

Кроме всего прочего использование внешнего кодогенератора может быть
предпочтительно в связи с отсутствием необходимости переименовывать
переменные внутри кода, а следовательно в связи с более простой
отладкой.

\section{Описание библиотеки для использования динамических функций}

Для совместного испольования набора динамических функций также
необходимо иметь библиотеку реализующую логику их взаимодействия.

Была разработана библиотека предоставляющая ряд сущностей:
\begin{code}
-- Объединяет две динамические функции в одну
dplus :: DFunction -> DFunction -> DFunction

-- Объединяют две таблицы данных в одну
stplus :: SymbolTable -> SymbolTable -> SymbolTable
rtplus :: ReadTable -> ReadTable -> ReadTable
shtplus :: ShowTable -> ShowTable -> ShowTable

-- По таблицам данных преобразовывают ввод во внутренние структуры
getFun :: SymbolTable -> String -> Maybe DFunction
getRead :: ReadTable -> String -> Maybe (String -> Dynamic)
argToDyn :: ReadTable -> Argument -> Maybe Dynamic

-- Преобразует данные из внутреннего представления во внешнее
getShow :: ShowTable -> Dynamic -> Maybe String

-- Производит полный разбор введённой строки
parseString :: String -> Maybe Function

-- Выполняет код и возвращает результат
eval :: SymbolTable -> ReadTable -> Function -> Maybe Dynamic
\end{code}

Кроме того создана функция реализующая полностью REPL
\begin{code}
data ProgramData =
  PD { readInput :: IO String,
       symbolTable :: SymbolTable,
       readTable :: ReadTable,
       showTable :: ShowTable,
       importModules :: [(String, (SymbolTable, ReadTable, ShowTable))]
     }

repl :: ProgramData -> IO ()
\end{code}

Таким образом предоставлены простые интерфейсы для совместного
использования динамических функций

Пример программы
\begin{code}
import DynamicFace
import qualified Simple as S
import qualified SimpleTemplate as ST
import Monad

main = repl $ SPD S.symbolTable, S.readTable, S.showTable
                  [("second", (ST.symbolTable, ST.readTable, ST.showTable))]

\end{code} %$

