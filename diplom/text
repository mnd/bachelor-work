Глава 1. Типизация

[копипаста из книжки]

Как мы видим безопасные языки приносят множество плюсов разработчикам
программ. К сожалению существует ряд задач, связанных с получением во
время работы большого количества даных разных типов. Таким образом для
того чтобы определить тип Result функции

readD :: StringTypeRepr -> StringDataRepr -> Result

необходимо определить глобальный тип данных DataUnit определяющий все
возможные типы данных

data DataUnit = Int Int | Integer Integer | Double Double | ...

и при создании новых модулей системы добавлять данные о новых
введённых типах данных в этот модуль. В таком случа мы сможем
определить функцию readD как

readD :: StringTypeRepr -> StringDataRepr -> DataUnit

Данное решение обладает является монолитным и, таким образом очень
плохо расширяется. Кроме того такое решение требует от программиста
знания о всех существующих типах данных, для того чтобы он не добавил
конструктор типа DataUnit с таким же именем, как у одного из заданных
ранее типов.

Другое возможное решение -- определение пары (TypeID, Data) и
использоваить unsafe-конструкции языка Haskell.

unsafeCoerce inputData :: Data

Аналогичным образом мы сможем извлекать данные из типа Data:

case typeID of
    ...
    integerID -> unsafeCoerce data :: Integer
    ...

Данное решение также не лишено недостатков: При использовании unsafe
преобразований программист должен сам следить за корректностью типов,
поскольку конструкция

case typeID of
    doubleID -> unsafeCoerce data :: Integer

будет корректно воспринята компилятором, но во время выполнения будет
вести себя достаточно неожиданно.

Глава 2. Существующие решения
2.1 Template Haskell

TH создан как гарантирующее безопасность типов расширение языка
Haskell. Данное расширение позволяет оперировать с конструкциями
корректными в языке Haskell на уровне абстрактных синтаксических
деревьев.

Так как данное расширение работает, также как и сам Haskell, в рамках
функциональной парадигмы программирования, то внутри функции
генерирующей тип DataUnit невозможно узнать информацию о типах данных
определенных в различных модулях системы.

2.2 Generic Haskell

Рассмотрим следующую задачу: Существует завод, структуры которого
можно определить как

data Factory  = Factory Director [Worker] [Builing]
data Director = Director Name Salary
data Worker   = Worker Name Salary
data Salary   = Salary Double
data Building = ...

Необходимо провести плановое увеличение зарплаты всех работников на
10%. Опишем функции решающие задачу

incF p (Factory d ws bs) = Factory (incD p d) (map (incW p) ws) bs
incD p (Director n s) = Director n (incS p s)
incW p (Worker n s)   = Worker n (incS p s)
incS p (Salary s)     = Salary ((1 + d) * s)

И имея такие функции мы сможем увеличить зарплату всех сотрудников на
10% вызвав функцию

incF 0.1 factory

Проблема данного решения в существовании большого количества функций,
которые не делают ничего, кроме обхода структур. Для того чтобы
устранить такую проблему созданы Generic Haskell библиотеки. При
использовании таких библиотек мы сможем увеличить зарплату всем
сотрудникам при помощи функции

everywhere (mkT $ incS p) factory

доверив создание логики обхода данных библиотечной функци. Generic
Haskell библиотеки генерируют функции обхода данных либо при помощи
Template Haskell, либо при помощи внешних генераторов, либо создавая
расширение для компилятора.

Кроме этого некоторые библиотеки для обобщенного программирования,
такие как SYB, имеют интерфейсы для создания обощённых функций. В
качестве примера рассмотрим написанный выше код код

mkT $ incS p

Этот код возвращает полиморфную функцию, которая для данных всех
типов, кроме Salary, возвращает переданное значение, а для типа Salary
возвращает результат применения функции (incS p)

Это достигается следующим образом: В язык добавляется генерация
идентефикатора типа

data TypeRep = TypeRep Key TyCon [TypeRep]
data Key = Key Int

В котором ключ уникален для каждого существующего типа данных. Имея
такое представление типов для создания полиморфной функции достаточно
проверить соответствует ли тип результата типу переданной функции. В
случае если типы равны, то при помощи unsafeCoerce обойти функции
проверки типов работающую во время компиляции, иначе вернуть
полиморфную функцию id.

mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a
mkT f = case cast f of
      	  Just g  -> g
	  Nothing -> id

cast :: (Typeable a, Typeable b) => a -> Maybe b
cast x = r
  where
    r = if typeOf x == typeOf (fromJust r)
          then Just $ unsafeCoerce x
	  else Nothing

Таким образом достигается проверка типов внутри функции во время
выполнения, а не во время компиляции и, одновременно, проводится
проверка безопасности типов.

Данный подход позволяет реализовать функцию gread умеющую разбирать
несколько типов данных

gread :: StringTypeRepr -> StringDataRepr -> a

Которую можно использовать следующим образом

gread integerID data :: Integer
gread doubleID  data :: Double

Как видно из этого примера у данного решения существует фатальный
недостаток: для его использования необходимо знать данные каких типов и
в каком порядке будут переданны системе во время работы.

Таким образом использовать generic библиотеки для создания
рассматриваемых систем невозможно.

2.3 Data.Dynamic

Dynamic типы распространяемые в комплекте с компилятором GHC
представляют из себя пару

data Dynamic = Dynamic TypeRep Data

Которая является типом данных оговорённом в первой главе. Кроме того
тип Dynamic предоставляет интерфейсы для преобразования данных в
Dynamic и для преобразования из типа Dynamic в первоначальный тип
данных. Благодаря тому, что все преобразования реализованные в данной
библиотеки проверяют корректность типов, а конструктор типа Dynamic
является скрытым, у программиста нет возможности нарушить безопасность
типов. Таким образом функция readD в терминах типа Dynamic может быть
записана следующим образом:

readD :: StringTypeRepr -> StringDataRepr -> Dynamic
readD t d = case t of
              "Integer" -> toDyn (read d :: Integer)
              "Double"  -> toDyn (read d :: Double)

Функция определённая таки образом выбирает тип данных во время
выполнения, но, к сожалению, такое решение также является монолитным,
поскольку не позволяет комбинировать функции для разбора данных из
разных модулей. Таким образом программист, создающий новый модуль для
системы должен знать в каком модуле объявлена функция разбирающая все
типы наиболее полно и вызывать эту функцию в качестве решения по
умолчанию:

readD t d = case t of
              "Integer" -> toDyn (read d :: Integer)
	      ...
              _  -> Module.readD t d

Для того чтобы решить эту проблему необходимо в качестве результата
возвращать значение, согнализирующее о том, смогли ли мы разобрать
переданные данные. С таким условием функция readD будет иметь
следующее определенеие

readD :: StringTypeRepr -> StringDataRepr -> Maybe Dynamic
readD t d = case t of
              "Integer" -> Just $ toDyn (read d :: Integer)
	      ...
              _  -> Nothing

В таком случае мы можем определить комбинатор, который объединяет две
реализации в одну

combine read1 read2 t d = case read1 t d of
                            Nothing -> read2 t d
			    result  -> result


Это решение справляется со всеми проблемами указанными выше: Оно не
является монолитным и оно включает в себя проверки безопасности типов
при использовании unsafe операций. Рассмотрим как при использовании
такого решения будут выглядеть типы динамических функций

func :: Dynamic -> Dynamic -> Maybe Dynamic

Так как данные функции создаются для использования при взаимодействии
со внешней средой, то нам необходима таблица функций, указывающая
соответствие между полученными текстовыми данными и выбираемой
функцией

symbolTable :: [(String, Dynamic -> Dynamic -> Maybe Dynamic)]

Как видно из данного определения при использовании так определённых
динамических функций нам придётся иметь по таблице символов для
функций каждой арности. И если в каком-то модуле появятся функции
неучтённой арности, то разработчику модуля придётся изменять код ядра
системы с целью добавления таблицы символов для функций новой
арности. К счастью данный недостаток легко устранив переписав
определение функции в виде

func :: [Dynamic] -> Maybe Dynamic

И используя единую таблицу функций

symbolTable :: [(String, Dynamic -> Dynamic -> Maybe Dynamic)]

Кроме таблицы символов такой системе потребуется таблица типов

readTable :: [(String, String -> Maybe Dynamic)]

Кажду функцию данной таблицы можно определить через описанную выше
функцию readD

readTable = [("Type1", readD "Type1"), ... ("TypeN", readD "TypeN")]

Также системе необходима таблица функций для вывода данных

showTable :: [(TypeRep, Dynamic -> Maybe String)]

Глава 3.

Как мы увидели из предыдущей главы готовых решений для создания
динамических функций нет. Давайте более подробно рассмотрим решение
построенное на типе Dynamic: Функция от двух аргументов,
диспетчеризующая типы Integer и Double может быть определена следующим
образом:

func :: [Dynamic] -> Maybe Dynamic
func [a1,a2] | (dynTypeRep a1 == typeOf (undefined :: Integer))
               && (dynTypeRep a2 == typeOf (undefined :: Integer))
	     = (fromDynamic a1 :: Maybe Integer) >>= \a1 ->
	       (fromDynamic a2 :: Maybe Integer) >>= \a2 ->
	       Just $ toDyn $ function a1 a2
             | (dynTypeRep a1 == typeOf (undefined :: Double))
               && (dynTypeRep a2 == typeOf (undefined :: Double))
	     = (fromDynamic a1 :: Maybe Double) >>= \a1 ->
	       (fromDynamic a2 :: Maybe Double) >>= \a2 ->
	       Just $ toDyn $ function a1 a2
	     | otherwise = Nothing
func _ = Nothing
	       
И данная функция потребует следующих таблиц:

symbolTable = [("func", func)]
readTable = [("Integer", toDyn . (read :: String -> Integer)),
             ("Double", toDyn . (read :: String -> Double))]
showTable = [(typeOf (undefined :: Integer),
              \a -> (fromDynamic a :: Maybe Integer) >>= Just . show),
	     (typeOf (undefined :: Double),
              \a -> (fromDynamic a :: Maybe Double) >>= Just . show)]

Программисту, как легко понять из данного кода, приходится писать
очень много служебного кода, и, вопреки приятому в среде программистов
правилу Dont't Repeat Yourself, по нескольку раз писать тип каждого
аргумента.

Данную неприятность можно решить создав DSL из которого будет
генерироваться служебный код.

3.1 DSEL на Template Haskell
Как было сказано выше Template Haskell позволяет генерировать
корректный код на Hskell во время компиляции, а следовательно при
использовании данного расшрения мы получаем возможность генерировать
части определениф функции. Давайте выделим основные части определения
функции

func [a1,a2] | $(typeTest [| a1 |] [t| Integer |])
               && $(typeTest [| a1 |] [t| Integer |])
	     = $(extractArg [| a1 |] [t| Integer |]) >>= \a1 ->
	       $(extractArg [| a2 |] [t| Integer |]) >>= \a2 ->
	       $(packResult [| function a1 a2 |])

В представленном выше коде $( ... ) это специальный синтаксис
определенный расширением Template Haskell для вызова функций во время
компиляции. Синтаксис [| code |] и [t| type |] также определён
расширением Template Haskell и возвращает дерево разбора для кода
'code' и типа 'type' соответственно.

Наборы функций typeTest достаточно легко заменить на одну функцию,
принимающую список пар (Аргемент, Тип):

$(typeTest [
    ([| a1 |], [t| Integer |]),
    ([| a2 |], [t| Integer |])
])

Немного более сложно возможно заменить последовательность функций
extractArg заканчивающуюся функцией packResult в качестве одной
функци. Для определения такого ряда в виде

$(extractAndEval [([| a1 |], [t| Integer |]),
                  ([| a2 |], [t| Integer |])]
		 [| function a1 a2 |])

необходимо произвести обход AST представляющего код "function a1 a2" и
заменить переменные a1 и a2 на сгенерированные дополнительно. Такая
потребность возникает из-за того, что синтаксические области видимости
разделяются в момент синтаксического разбора, а не после генерации
деревьев. Это легко проследить на следующем примере

runQ [| \a -> \a -> a |]
==> LamE [VarP a_2] (LamE [VarP a_3] (VarE a_3))

В этом примере переменная a внешней лямбда функции получила имя a_2, а
переменная a внутренней лямбда функции получила имя a_3.

Таким образом решение в окончательном виде, при использовании ещё
одного дополнительного синтаксиса 'var возвращающего имя переменной
var, может выглядеть следующим образом

func :: [Dynamic] -> Maybe Dynamic
func [a, b] = $(typesAndExecutesN [
                   ([('a, [t| Integer |]),
                     ('b, [t| Integer |])],
                    [| function a b |]),
                   
                   ([('a, [t| Double |]),
                     ('b, [t| Double |])],
                    [| function a b |])
                ])
func _ = Nothing

genSymbolTable [("func", [| func |])]
genReadShowTable [
  ([t| Integer |], "Integer", [| read |], [| show |]),
  ([t| Double |], "Double",  [| read |], [| show |])
  ]

Но в данном решении есть одна проблема:

Так как GHC проводит проверку типов как до запуска Template Haskell
так и после, то если функция function реализована не полиморфно, то
первая проверка типа не проидет. В качестве work around можно
предложить следующий вариант

[| (unsafeCoerce function :: (a -> a -> a)) a b |]

Который вносит дополнительное место в котором может произойти
неотлавливаемая ошибка типов.

3.2 DSL реализованный внешним парсером

В качестве внешнего языка из которого генерируется код Dynamic функций
мной был предложен язык следующего вида:

Integer func (Integer a, Integer b)
Double func (Double a, Double b)
{
  function a b
}

Double func (Double a, Integer b)
Double func (Integer b, Double a)
{
  function a b
}

typedef readTypes = [Integer, Double];

readTypes read (String s) { read s }
String show (readTypes a) { show a }

Этот язык предоставляет следующие возможности:

1. Для одного и того же тела функции можно указать несколько наборов
   типов аргументов, что удобно для полиморфных функций.
2. Имена аргументов в разных определениях можно менять местами, что
   позволяет описывать симметричные функции.
3. Оператор typedef позволяет указывать списки типов. При
   использовании такого списка в определении -- определение
   развернётся в ряд определений, в каждом из которых будет подставлен
   один из типов указанных в списке.

3.3 DSEL с использованием Quasi Quotation или почему я не стал его
реализовывать

Расширение языка Haskell под названием Quasi Quotation позволяет
определять кодогенераторы работающие во время компиляции в виде

[$parser| mani lines
   code that describe
   somthing interesting |]

Код внутри блока [$parser| ... |] передаётся парсеру как строка. На
вывод парсер должен вернуть корректное с точки зрения компилятора
синтаксическое дерево. Данное расширение удобно использовать для
генерации объектов сложного типа, но крайне сложно использовать для
генерации Haskell программы, поскольку для этого придётся реализовать
полностью разбор и генерацию синтаксических деревьев, что является
достаточно трудоёмкой задачей.

3.4 Сравнение двух реализаций

Главным приемуществом реализации на Template Haskell является низкая
стоимость изменения или дополнения функционала, но это достигается
ценой ясности синтаксиса, необходимостью явного определения таблицы
символов и таблиц функций ввода и вывода, а также проблемой при
описании не полиморфных функций.

Реализация внешнего парсера менее переносима: для его использования не
достаточно иметь установленный ghc в системе, но также необходимо
иметь скомпилированный кодогенератор. Данная проблема может быть
минимизирована при реализации кодогенератора на языке Haskell. 

Кроме всего прочего использование внешнего кодогенератора может быть
предпочтительно в связи с отсутствием необходимости переименовывать
переменные внутри кода, а следовательно в связи с более простой
отладкой.

3.5 Описание библиотеки для использования динамических функций

Для совместного испольования набора динамических функций также
необходимо иметь библиотеку реализующую логику их взаимодействия.