% -*- mode: LaTeX; mode: auto-fill; mode: flyspell; coding: koi8-r; -*-
\chapter{Типизация}

Язык программирования Haskell является статически типизированным. Это
означает что проверка на наличие ошибок типов происходит во время
компиляции, а не во время выполнения.

Будучи статическими, системы типов таких языков по необходимости
консервативны: они способны однозначно доказать отсутствие
определенных нежелательных видов поведения, но не могут доказать их
наличие, и, следовательно, иногда вынуждены отвергать программы,
которые на самом деле при выполнении ведут себя корректным
образом. Например, программа

\begin{code}
if <сложная проверка> then S else <ошибка типа>
\end{code}
будет отвергнута как неверно типизированная, даже если
\small<сложная~проверка>\normalsize{} всегда выдает значение ``истина'', поскольку
статический анализ неспособен это заметить.

Самое очевидное достоинство статической проверки типов --- это то, что
она помогает раньше обнаружить некоторые ошибки в программах. Рано
обнаруженные ошибки могут быть исправлены немедленно, а не оставаться
скрытыми на долгое время, чтобы потом неожиданно всплыть, когда
программист занят чем-то совершенно другим --- или даже после того, как
программа выпущена для потребителей. Более того, часто ошибки можно
более точно описать при проверке типов, а не во время выполнения,
когда их последствия могут обнаружиться не сразу, а спустя некоторое
время после того, как программа начинает работать неправильно.

Для некоторых видов программ процедура проверки типов может служить
инструментом сопровождения. Например, программист, которому требуется
изменить определение сложной структуры, может не искать вручную все
места в программе, где требуется изменить код, имеющий дело с этой
структурой. Как только изменяется определение типа данных, во всех
этих фрагментах кода возникают ошибки типов, и их можно найти путем
простого прогона компилятора и исправления тех мест, где проверка
типов не проходит.

Типы полезны также при чтении программ. Объявления типов в заголовках
процедур и интерфейсах модулей представляют собой разновидность
документации и дают ценную информацию о поведении программы. Более
того, в отличие от описаний, упрятанных в комментарии, такая
документация не может устареть, поскольку она проверяется при каждом
прогоне компилятора. Эта роль типов особенно существенна в сигнатурах
модулей.

Кроме того Haskell считается безопасным языком. Всякий язык высокого
уровня предоставляет программисту абстрактный взгляд на работу
машины. Безопасность означает, что язык способен гарантировать
целостность этих абстракций, а также абстракций более высокого уровня,
вводимых при помощи описательных средств языка. Например, язык может
предоставлять массивы, с операциями доступа к ним и их обновления, как
абстракцию нижележащей машинной памяти. Программист, использующий
такой язык, ожидает, что массив можно модифицировать только через
явное использование операций обновления --- а не, скажем, путем записи в
память за границами какой-либо структуры данных.  Подобным же образом,
ожидается, что к переменным со статической областью видимости можно
обратиться только изнутри этой области, что стек вызовов действительно
ведет себя как стек и т. д.

Безопасность языка --- это не то же самое, что статическая безопасность
типов. Безопасности языка можно достичь при помощи системы типов, но
можно добиться ее и с помощью проверок на стадии выполнения, которые
отлавливают бессмысленные операции в момент, когда производится
попытка их исполнить, и останавливают программу или порождают
исключение. К примеру, Scheme является безопасным языком, несмотря на
отсутствие статической системы типов.

Как правило, достичь безопасности выполнения при помощи только
лишь статической типизации невозможно. Например, такие статически
типизированные языки как Haskell и Java, динамически производят
проверку выхода за границы массивов.

Безопасность языка редко бывает абсолютной. Безопасные языки часто
предоставляют программистам ``черные ходы'', например, вызовы функций,
написанных на других, возможно небезопасных, языках. Иногда такие
черные ходы, в регулируемом виде, даже содержатся внутри самого языка
--- например, Obj.magic в OCaml, или unsafeCoerce в Haskell.

Как мы видим безопасные статически типизированные языки приносят
множество плюсов разработчикам программ. К сожалению существует ряд
задач, связанных с получением во время работы большого количества
данных разных типов, в которых использование только безопасных
конструкций делает код не расширяемым.

В качестве примера можно рассмотреть систему компьютерной алгебры. Эта
система получает данные разных типов через текстовый интерфейс и
обрабатывает их во время выполнения. В такой системе для того чтобы
определить тип Result функции
\begin{code}
readD :: StringTypeRepr -> StringDataRepr -> Result
\end{code}
преобразующей введённые данные во внутреннее представление,
использующееся модулями системы, необходимо определить глобальный тип
данных DataUnit определяющий все возможные типы данных
\begin{code}
data DataUnit = Int Int
              | Integer Integer 
              | Double Double 
              ...
\end{code}
и, при создании новых модулей для системы, добавлять информацию о
появившихся типах данных в качестве конструктора для типа DataUnit. В
таком случае мы сможем определить функцию readD как
\begin{code}
readD :: StringTypeRepr -> StringDataRepr -> DataUnit
\end{code}

Данное решение является монолитным и требует от программиста знания
внутреннего устройства ядра системы, а также знания о всех
существующих типах данных, для того чтобы он не добавил конструктор
типа DataUnit с таким же именем, как у одного из заданных ранее типов.

Другое возможное решение --- определить парк (TypeID, Data) и
использовать unsafe возможности языка Haskell для преобразования
введённых данных к типу Data
\begin{code}
unsafeCoerce inputData :: Data
\end{code}
При таком подходе для работы с данными для начала необходимо их извлечь из типа Data
\begin{code}
case typeID of
  ...
  integerID -> unsafeCoerce data :: Integer
  ...
\end{code}

Такое решение также не лишено недостатков: При использовании unsafe
преобразований программист должен сам следить за корректностью типов,
поскольку конструкция
\begin{code}
case typeID of
  doubleID -> unsafeCoerce data :: Integer
\end{code}
будет корректно воспринята компилятором, но во время выполнения будет
вести себя достаточно неожиданно.
