% -*- mode: LaTeX; mode: auto-fill; mode: flyspell; coding: utf-8; -*-

\documentclass[a4paper,12pt]{article}

%Чтобы можно было использовать русские буквы в формулах
%но в случае использования предупреждать об этом
\usepackage[warn]{mathtext}
%выбор внутренней TeX-кодировки
%можно опустить - вызываю по привычке
\usepackage[T2A]{fontenc}
%выбор кодовой страницы документа
\usepackage[utf8x]{inputenc}
%выбор языка документа
\usepackage[english,russian]{babel}
%начинать первый параграф с красной строки
\usepackage{indentfirst}
%математика
\usepackage{amsmath}

\usepackage{verbatim}
\newenvironment{code}{\footnotesize\verbatim}{\endverbatim\normalsize}

\sloppy                         % Hyphenation is a problem..

\title{Title}
\date{}
\author{Меринов Н.Д.}

\begin{document}
\section{Типизация}

Язык программирования Haskell является статически типизированным. Это
означает что проверка на наличие ошибок типов происходит во время
компиляции, а не во время выполнения.

Будучи статическими, системы типов таких языков по необходимости
консервативны: они способны однозначно доказать отсутствие
определенных нежелательных видов поведения, но не могут доказать их
наличие, и, следовательно, иногда вынуждены отвергать программы,
которые на самом деле при выполнении ведут себя корректным
образом. Например, программа

\begin{code}
  if <сложная проверка> then S else <ошибка типа>
\end{code}
будет отвергнута как неверно типизированная, даже если
<сложная~проверка> всегда выдает значение «истина», поскольку
статический анализ неспособен это заметить.

Самое очевидное достоинство статической проверки типов — это то, что
она помогает раньше обнаружить некоторые ошибки в программах. Рано
обнаруженные ошибки могут быть исправлены немедленно, а не оставаться
скрытыми на долгое время, чтобы потом неожиданно всплыть, когда
программист занят чем-то совершенно другим — или даже после того, как
программа выпущена для потребителей. Более того, часто ошибки можно
более точно описать при проверке типов, а не во время выполнения,
когда их последствия могут обнаружиться не сразу, а спустя некоторое
время после того, как программа начинает работать неправильно.

Для некоторых видов программ процедура проверки типов может служить
инструментом сопровождения. Например, программист, которому требуется
изменить определение сложной структуры, может не искать вручную все
места в программе, где требуется изменить код, имеющий дело с этой
структурой. Как только изменяется определение типа данных, во всех
этих фрагментах кода возникают ошибки типов, и их можно найти путем
простого прогона компилятора и исправления тех мест, где проверка
типов не проходит.

Типы полезны также при чтении программ. Объявления типов в заголовках
процедур и интерфейсах модулей представляют собой разновидность
документации и дают ценную информацию о поведении программы. Более
того, в отличие от описаний, упрятанных в комментарии, такая
документация не может устареть, поскольку она проверяется при каждом
прогоне компилятора. Эта роль типов особенно существенна в сигнатурах
модулей.

Кроме того Haskell считается безопасным языком. Всякий язык высокого
уровня предоставляет программисту абстрактный взгляд на работу
машины. Безопасность означает, что язык способен гарантировать
целостность этих абстракций, а также абстракций более высокого уровня,
вводимых при помощи описательных средств языка. Например, язык может
предоставлять массивы, с операциями доступа к ним и их обновления, как
абстракцию нижележащей машинной памяти. Программист, использующий
такой язык, ожидает, что массив можно модифицировать только через
явное использование операций обновления — а не, скажем, путем записи в
память за границами какой-либо структуры данных.  Подобным же образом,
ожидается, что к переменным со статической областью видимости можно
обратиться только изнутри этой области, что стек вызовов действительно
ведет себя как стек и т. д.

Безопасность языка — это не то же самое, что статическая безопасность
типов. Безопасности языка можно достичь при помощи системы типов, но
можно добиться ее и с помощью проверок на стадии выполнения, которые
отлавливают бессмысленные операции в момент, когда производится
попытка их исполнить, и останавливают программу или порождают
исключение. К примеру, Scheme является безопасным языком, несмотря на
отсутствие статической системы типов.

Как правило, достичь безопасности выполнения при помощи только лишь
статической типизации невозможно. Например, такие статически
типизированные языки как Haskell и Java, динамически производят
проверку выхода за границы массивов.

Безопасность языка редко бывает абсолютной. Безопасные языки часто
предоставляют программистам «черные ходы», например, вызовы функций,
написанных на других, возможно небезопасных, языках. Иногда такие
черные ходы, в регулируемом виде, даже содержатся внутри самого языка
— например, Obj.magic в OCaml, или unsafeCoerce в Haskell.

Как мы видим безопасные статически типизированные языки приносят
множество плюсов разработчикам программ. К сожалению существует ряд
задач, связанных с получением во время работы большого количества
данных разных типов, в которых использование только безопасных
конструкций делает код не расширяемым.

В качестве примера можно рассмотреть систему компьютерной алгебры. Эта
система получает данные разных типов через текстовый интерфейс и
обрабатывает их во время выполнения. В такой системе для того чтобы
определить тип Result функции
\begin{code}
  readD :: StringTypeRepr -> StringDataRepr -> Result
\end{code}
преобразующей введённые данные во внутреннее представление,
использующееся модулями системы, необходимо определить глобальный тип
данных DataUnit определяющий все возможные типы данных
\begin{code}
data DataUnit = Int Int
              | Integer Integer 
              | Double Double 
              ...
\end{code}
и, при создании новых модулей для системы, добавлять информацию о
появившихся типах данных в качестве конструктора для типа DataUnit. В
таком случае мы сможем определить функцию readD как
\begin{code}
  readD :: StringTypeRepr -> StringDataRepr -> DataUnit
\end{code}

Данное решение является монолитным и требует от программиста знания
внутреннего устройства ядра системы, а также знания о всех
существующих типах данных, для того чтобы он не добавил конструктор
типа DataUnit с таким же именем, как у одного из заданных ранее типов.

Другое возможное решение --- определить парк (TypeID, Data) и
использовать unsafe возможности языка Haskell для преобразования
введённых данных к типу Data
\begin{code}
unsafeCoerce inputData :: Data
\end{code}
При таком подходе для работы с данными для начала необходимо их извлечь из типа Data
\begin{code}
case typeID of
  ...
  integerID -> unsafeCoerce data :: Integer
  ...
\end{code}

Такое решение также не лишено недостатков: При использовании unsafe
преобразований программист должен сам следить за корректностью типов,
поскольку конструкция
\begin{code}
case typeID of
  doubleID -> unsafeCoerce data :: Integer
\end{code}
будет корректно воспринята компилятором, но во время выполнения будет
вести себя достаточно неожиданно.

\section{Существующие решения}
\subsection{Template Haskell}

TH создан как гарантирующее безопасность типов расширение языка
Haskell. Данное расширение позволяет оперировать с конструкциями
корректными в языке Haskell на уровне абстрактных синтаксических
деревьев.

Так как данное расширение работает, также как и сам Haskell, в рамках
функциональной парадигмы программирования, то внутри функции
генерирующей тип DataUnit невозможно узнать информацию о типах данных
определенных в различных модулях системы.

\subsection{Generic Haskell}

Рассмотрим следующую задачу: Существует завод, структуры которого
можно определить как
\begin{code}
  data Factory  = Factory Director [Worker] [Builing]
  data Director = Director Name Salary
  data Worker   = Worker Name Salary
  data Salary   = Salary Double
  data Building = ...
\end{code}
Необходимо провести плановое увеличение зарплаты всех работников на
10%. Опишем функции решающие задачу

\begin{code}
  incF p (Factory d ws bs) = Factory (incD p d) (map (incW p) ws) bs
  incD p (Director n s) = Director n (incS p s)
  incW p (Worker n s)   = Worker n (incS p s)
  incS p (Salary s)     = Salary ((1 + d) * s)
\end{code}
И имея такие функции мы сможем увеличить зарплату всех сотрудников на
10% вызвав функцию

\begin{code}
  incF 0.1 factory
\end{code}

Проблема данного решения в существовании большого количества функций,
которые не делают ничего, кроме обхода структур. Для того чтобы
устранить такую проблему созданы Generic Haskell библиотеки. При
использовании таких библиотек мы сможем увеличить зарплату всем
сотрудникам при помощи функции

\begin{code}
  everywhere (mkT $ incS p) factory
\end{code}

доверив создание логики обхода данных библиотечной функци. Generic
Haskell библиотеки генерируют функции обхода данных либо при помощи
Template Haskell, либо при помощи внешних генераторов, либо создавая
расширение для компилятора.

Кроме этого некоторые библиотеки для обобщенного программирования,
такие как SYB, имеют интерфейсы для создания обощённых функций. В
качестве примера рассмотрим написанный выше код код

\begin{code}
  mkT $ incS p
\end{code}

Этот код возвращает полиморфную функцию, которая для данных всех
типов, кроме Salary, возвращает переданное значение, а для типа Salary
возвращает результат применения функции (incS p)

Это достигается следующим образом: В язык добавляется генерация
идентефикатора типа

\begin{code}
  data TypeRep = TypeRep Key TyCon [TypeRep]
  data Key = Key Int
\end{code}

В котором ключ уникален для каждого существующего типа данных. Имея
такое представление типов для создания полиморфной функции достаточно
проверить соответствует ли тип результата типу переданной функции. В
случае если типы равны, то остается, при помощи функции unsafeCoerce,
обойти проверку типов, работающую во время компиляции. Иначе вернуть
полиморфную функцию id.

\begin{code}
  mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a
  mkT f = case cast f of
            Just g  -> g
            Nothing -> id
 
  cast :: (Typeable a, Typeable b) => a -> Maybe b
  cast x = r
    where
      r = if typeOf x == typeOf (fromJust r)
            then Just $ unsafeCoerce x
            else Nothing
\end{code} %$

Таким образом осуществляется проверка корректности типов во время
выполнения, а не во время компиляции.

Данный подход позволяет реализовать функцию gread умеющую разбирать
несколько типов данных
\begin{code}
  gread :: StringTypeRepr -> StringDataRepr -> a
\end{code}

Такую функцию можно использовать следующим образом
\begin{code}
  gread integerID data :: Integer
  gread doubleID  data :: Double
\end{code}

Как видно из этого примера у данного решения существует фатальный
недостаток: для его использования необходимо знать данные каких типов
и в каком порядке будут переданны системе во время работы.

Таким образом использовать generic библиотеки для создания
рассматриваемых систем невозможно.

\subsection{Data.Dynamic}

Dynamic типы распространяемые в комплекте с компилятором GHC
представляют из себя пару

\begin{code}
  data Dynamic = Dynamic TypeRep Data
\end{code}

Которая является типом данных оговорённом в первой главе. Кроме того
тип Dynamic предоставляет интерфейсы для преобразования данных в
Dynamic и для преобразования из типа Dynamic в первоначальный тип
данных. Благодаря тому, что все преобразования реализованные в данной
библиотеки проверяют корректность типов, а конструктор типа Dynamic
является скрытым, у программиста нет возможности нарушить безопасность
типов. Таким образом функция readD в терминах типа Dynamic может быть
записана следующим образом:

\begin{code}
  readD :: StringTypeRepr -> StringDataRepr -> Dynamic
  readD t d = case t of
                "Integer" -> toDyn (read d :: Integer)
                "Double"  -> toDyn (read d :: Double)
\end{code}

Функция определённая таки образом выбирает тип данных во время
выполнения, но, к сожалению, такое решение также является монолитным,
поскольку не позволяет комбинировать функции для разбора данных из
разных модулей. Таким образом программист, создающий новый модуль для
системы должен знать в каком модуле объявлена функция разбирающая все
типы наиболее полно и вызывать эту функцию в качестве решения по
умолчанию:

\begin{code}
  readD t d = case t of
                "Integer" -> toDyn (read d :: Integer)
                ...
                _  -> Module.readD t d
\end{code}

Для того чтобы решить эту проблему необходимо в качестве результата
возвращать значение, согнализирующее о том, смогли ли мы разобрать
переданные данные. С таким условием функция readD будет иметь
следующее определенеие

\begin{code}
  readD :: StringTypeRepr -> StringDataRepr -> Maybe Dynamic
  readD t d = case t of
                "Integer" -> Just (toDyn (read d :: Integer))
                ...
                _  -> Nothing
\end{code}

В таком случае мы можем определить комбинатор, который объединяет две
реализации в одну

\begin{code}
  combine read1 read2 t d = case read1 t d of
                              Nothing -> read2 t d
                              result  -> result
\end{code}

Это решение справляется со всеми проблемами указанными выше: Оно не
является монолитным и оно включает в себя проверки безопасности типов
при использовании unsafe операций. Рассмотрим как при использовании
такого решения будут выглядеть типы динамических функций

\begin{code}
  func :: Dynamic -> Dynamic -> Maybe Dynamic
\end{code}

Так как данные функции создаются для использования при взаимодействии
со внешней средой, то нам необходима таблица функций, указывающая
соответствие между полученными текстовыми данными и выбираемой
функцией

\begin{code}
  symbolTable :: [(String, Dynamic -> Dynamic -> Maybe Dynamic)]
\end{code}

Как видно из данного определения при использовании так определённых
динамических функций нам придётся иметь по таблице символов для
функций каждой арности. И если в каком-то модуле появятся функции
неучтённой арности, то разработчику модуля придётся изменять код ядра
системы с целью добавления таблицы символов для функций новой
арности. К счастью данный недостаток легко устранив переписав
определение функции в виде

\begin{code}
  func :: [Dynamic] -> Maybe Dynamic
\end{code}

И используя единую таблицу функций

\begin{code}
  symbolTable :: [(String, Dynamic -> Dynamic -> Maybe Dynamic)]
\end{code}

Кроме таблицы символов такой системе потребуется таблица типов

\begin{code}
  readTable :: [(String, String -> Maybe Dynamic)]
\end{code}

Кажду функцию данной таблицы можно определить через описанную выше
функцию readD

\begin{code}
  readTable = [("Type1", readD "Type1"), ... ("TypeN", readD "TypeN")]
\end{code}

Также системе необходима таблица функций для вывода данных

\begin{code}
  showTable :: [(TypeRep, Dynamic -> Maybe String)]
\end{code}

\section{}

Как мы увидели из предыдущей главы готовых решений для создания
динамических функций нет. Давайте более подробно рассмотрим решение
построенное на типе Dynamic: Функция от двух аргументов,
диспетчеризующая типы Integer и Double может быть определена следующим
образом:

\begin{code}
func :: [Dynamic] -> Maybe Dynamic
func [a1,a2] | (dynTypeRep a1 == typeOf (undefined :: Integer))
               && (dynTypeRep a2 == typeOf (undefined :: Integer))
	     = (fromDynamic a1 :: Maybe Integer) >>= \a1 ->
	       (fromDynamic a2 :: Maybe Integer) >>= \a2 ->
	       Just $ toDyn $ function a1 a2
             | (dynTypeRep a1 == typeOf (undefined :: Double))
               && (dynTypeRep a2 == typeOf (undefined :: Double))
	     = (fromDynamic a1 :: Maybe Double) >>= \a1 ->
	       (fromDynamic a2 :: Maybe Double) >>= \a2 ->
	       Just $ toDyn $ function a1 a2
	     | otherwise = Nothing
func _ = Nothing
\end{code}	       

И данная функция потребует следующих таблиц:

\begin{code}
symbolTable = [("func", func)]
readTable = [("Integer", toDyn . (read :: String -> Integer)),
             ("Double", toDyn . (read :: String -> Double))]
showTable = [(typeOf (undefined :: Integer),
              \a -> (fromDynamic a :: Maybe Integer) >>= Just . show),
	     (typeOf (undefined :: Double),
              \a -> (fromDynamic a :: Maybe Double) >>= Just . show)]
\end{code}

Программисту, как легко понять из данного кода, приходится писать
очень много служебного кода, и, вопреки приятому в среде программистов
правилу Dont't Repeat Yourself, по нескольку раз писать тип каждого
аргумента.

Данную неприятность можно решить создав DSL из которого будет
генерироваться служебный код.

\subsection{DSEL на Template Haskell}
Как было сказано выше Template Haskell позволяет генерировать
корректный код на Hskell во время компиляции, а следовательно при
использовании данного расшрения мы получаем возможность генерировать
части определениф функции. Давайте выделим основные части определения
функции

\begin{code}
func [a1,a2] | $(typeTest [| a1 |] [t| Integer |])
               && $(typeTest [| a1 |] [t| Integer |])
	     = $(extractArg [| a1 |] [t| Integer |]) >>= \a1 ->
	       $(extractArg [| a2 |] [t| Integer |]) >>= \a2 ->
	       $(packResult [| function a1 a2 |])
\end{code} %$


В представленном выше коде \$( ... ) это специальный синтаксис
определенный расширением Template Haskell для вызова функций во время
компиляции. Синтаксис [| code |] и [t| type |] также определён
расширением Template Haskell и возвращает дерево разбора для кода
'code' и типа 'type' соответственно.

Наборы функций typeTest достаточно легко заменить на одну функцию,
принимающую список пар (Аргемент, Тип):

\begin{code}
  $(typeTest [
      ([| a1 |], [t| Integer |]),
      ([| a2 |], [t| Integer |])
  ])
\end{code} %$
Немного более сложно возможно заменить последовательность функций
extractArg заканчивающуюся функцией packResult в качестве одной
функци. Для определения такого ряда в виде

\begin{code}
  $(extractAndEval [([| a1 |], [t| Integer |]),
                     ([| a2 |], [t| Integer |])]
                   [| function a1 a2 |])
\end{code} %$

необходимо произвести обход AST представляющего код "function a1 a2" и
заменить переменные a1 и a2 на сгенерированные дополнительно. Такая
потребность возникает из-за того, что синтаксические области видимости
разделяются в момент синтаксического разбора, а не после генерации
деревьев. Это легко проследить на следующем примере

\begin{code}
runQ [| \a -> \a -> a |]
==> LamE [VarP a_2] (LamE [VarP a_3] (VarE a_3))
\end{code}

В этом примере переменная a внешней лямбда функции получила имя a\_2, а
переменная a внутренней лямбда функции получила имя a\_3.

Таким образом решение в окончательном виде, при использовании ещё
одного дополнительного синтаксиса 'var возвращающего имя переменной
var, может выглядеть следующим образом

\begin{code}
func :: [Dynamic] -> Maybe Dynamic
func [a, b] = $(typesAndExecutesN [
                   ([('a, [t| Integer |]),
                     ('b, [t| Integer |])],
                    [| function a b |]),
                   
                   ([('a, [t| Double |]),
                     ('b, [t| Double |])],
                    [| function a b |])
                ])
func _ = Nothing

genSymbolTable [("func", [| func |])]
genReadShowTable [
  ([t| Integer |], "Integer", [| read |], [| show |]),
  ([t| Double |], "Double",  [| read |], [| show |])
  ]
\end{code} %$

Но в данном решении есть одна проблема:

Так как GHC проводит проверку типов как до запуска Template Haskell
так и после, то если функция function реализована не полиморфно, то
первая проверка типа не проидет. В качестве work around можно
предложить следующий вариант

\begin{code}
  [| (unsafeCoerce function :: (a -> a -> a)) a b |]
\end{code}

Который вносит дополнительное место в котором может произойти
неотлавливаемая ошибка типов.

\subsection{DSL реализованный внешним парсером}

В качестве внешнего языка из которого генерируется код Dynamic функций
мной был предложен язык следующего вида:

Integer func (Integer a, Integer b)
Double func (Double a, Double b)
{
  function a b
}

\begin{code}
  Double func (Double a, Integer b)
  Double func (Integer b, Double a)
  {
    function a b
  }

  typedef readTypes = [Integer, Double];

  readTypes read (String s) { read s }
  String show (readTypes a) { show a }
\end{code}

Этот язык предоставляет следующие возможности:

1. Для одного и того же тела функции можно указать несколько наборов
   типов аргументов, что удобно для полиморфных функций.
2. Имена аргументов в разных определениях можно менять местами, что
   позволяет описывать симметричные функции.
3. Оператор typedef позволяет указывать списки типов. При
   использовании такого списка в определении -- определение
   развернётся в ряд определений, в каждом из которых будет подставлен
   один из типов указанных в списке.

\subsection{DSEL с использованием Quasi Quotation или почему я не стал его
реализовывать}

Расширение языка Haskell под названием Quasi Quotation позволяет
определять кодогенераторы работающие во время компиляции в виде

\begin{code}
  [$parser| mani lines
    code that describe
    somthing interesting |]
\end{code} %$
Код внутри блока [\$parser| ... |] передаётся парсеру как строка. На
вывод парсер должен вернуть корректное с точки зрения компилятора
синтаксическое дерево. Данное расширение удобно использовать для
генерации объектов сложного типа, но крайне сложно использовать для
генерации Haskell программы, поскольку для этого придётся реализовать
полностью разбор и генерацию синтаксических деревьев, что является
достаточно трудоёмкой задачей. 

\subsection{Сравнение двух реализаций}

Главным приемуществом реализации на Template Haskell является низкая
стоимость изменения или дополнения функционала, но это достигается
ценой ясности синтаксиса, необходимостью явного определения таблицы
символов и таблиц функций ввода и вывода, а также проблемой при
описании не полиморфных функций.

Реализация внешнего парсера менее переносима: для его использования не
достаточно иметь установленный ghc в системе, но также необходимо
иметь скомпилированный кодогенератор. Данная проблема может быть
минимизирована при реализации кодогенератора на языке Haskell. 

Кроме всего прочего использование внешнего кодогенератора может быть
предпочтительно в связи с отсутствием необходимости переименовывать
переменные внутри кода, а следовательно в связи с более простой
отладкой.

\subsection{Описание библиотеки для использования динамических функций}

Для совместного испольования набора динамических функций также
необходимо иметь библиотеку реализующую логику их взаимодействия.
\end{document}
