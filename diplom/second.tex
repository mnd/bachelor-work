\chapter{Существующие решения}

\section{Template Haskell}

TH создан как гарантирующее безопасность типов расширение языка
Haskell. Данное расширение позволяет оперировать с конструкциями
корректными в языке Haskell на уровне абстрактных синтаксических
деревьев.

При помощи Template Haskell возможно использование функций
\begin{code}
$(zipN 3)
$(deriveShow ''Maybe)
\end{code}
Которые при компиляции развернутся в
\begin{code}
let zip = \ y1 y2 y3 ->
  case (y1,y2,y3) of
    (x1:xs1,x2:xs2,x3:xs3) -> (x1,x2,x3) : ff xs1 xs2 xs3
    (_,_,_) -> []
in zip

instance Show (Maybe a) where
  show (Just a) = "Just" ++ show a
  show (Nothing) = "Nothing"
\end{code}

К сожалению, так как данное расширение работает, также как и сам
Haskell, в рамках функциональной парадигмы программирования, то внутри
функции генерирующей тип DataUnit невозможно узнать информацию о типах
данных определенных в различных модулях системы.

\section{Generic Haskell}

Рассмотрим следующую задачу: Существует завод, структуры которого
можно определить как
\begin{code}
  data Factory  = Factory Director [Worker] [Builing]
  data Director = Director Name Salary
  data Worker   = Worker Name Salary
  data Salary   = Salary Double
  data Building = ...
\end{code}
Необходимо провести плановое увеличение зарплаты всех работников на
10%. Опишем функции решающие задачу

\begin{code}
  incF p (Factory d ws bs) = Factory (incD p d) (map (incW p) ws) bs
  incD p (Director n s) = Director n (incS p s)
  incW p (Worker n s)   = Worker n (incS p s)
  incS p (Salary s)     = Salary ((1 + d) * s)
\end{code}
И имея такие функции мы сможем увеличить зарплату всех сотрудников на
10% вызвав функцию

\begin{code}
  incF 0.1 factory
\end{code}

Проблема данного решения в существовании большого количества функций,
которые не делают ничего, кроме обхода структур. Для того чтобы
устранить такую проблему созданы Generic Haskell библиотеки. При
использовании таких библиотек мы сможем увеличить зарплату всем
сотрудникам при помощи функции

\begin{code}
  everywhere (mkT $ incS p) factory
\end{code}

доверив создание логики обхода данных библиотечной функци. Generic
Haskell библиотеки генерируют функции обхода данных либо при помощи
Template Haskell, либо при помощи внешних генераторов, либо создавая
расширение для компилятора.

Кроме этого некоторые библиотеки для обобщенного программирования,
такие как SYB, имеют интерфейсы для создания обощённых функций. В
качестве примера рассмотрим написанный выше код код

\begin{code}
  mkT $ incS p
\end{code}

Этот код возвращает полиморфную функцию, которая для данных всех
типов, кроме Salary, возвращает переданное значение, а для типа Salary
возвращает результат применения функции (incS p)

Это достигается следующим образом: В язык добавляется генерация
идентефикатора типа

\begin{code}
  data TypeRep = TypeRep Key TyCon [TypeRep]
  data Key = Key Int
\end{code}

В котором ключ уникален для каждого существующего типа данных. Имея
такое представление типов для создания полиморфной функции достаточно
проверить соответствует ли тип результата типу переданной функции. В
случае если типы равны, то остается, при помощи функции unsafeCoerce,
обойти проверку типов, работающую во время компиляции. Иначе вернуть
полиморфную функцию id.

\begin{code}
  mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a
  mkT f = case cast f of
            Just g  -> g
            Nothing -> id
 
  cast :: (Typeable a, Typeable b) => a -> Maybe b
  cast x = r
    where
      r = if typeOf x == typeOf (fromJust r)
            then Just $ unsafeCoerce x
            else Nothing
\end{code} %$

Таким образом осуществляется проверка корректности типов во время
выполнения, а не во время компиляции.

Данный подход позволяет реализовать функцию gread умеющую разбирать
несколько типов данных
\begin{code}
  gread :: StringTypeRepr -> StringDataRepr -> a
\end{code}

Такую функцию можно использовать следующим образом
\begin{code}
  gread integerID data :: Integer
  gread doubleID  data :: Double
\end{code}

Как видно из этого примера у данного решения существует фатальный
недостаток: для его использования необходимо знать данные каких типов
и в каком порядке будут переданны системе во время работы.

Таким образом использовать generic библиотеки для создания
рассматриваемых систем невозможно.

\section{Data.Dynamic}

Dynamic типы распространяемые в комплекте с компилятором GHC
представляют из себя пару

\begin{code}
  data Dynamic = Dynamic TypeRep Data
\end{code}

Которая является типом данных оговорённом в первой главе. Кроме того
тип Dynamic предоставляет интерфейсы для преобразования данных в
Dynamic и для преобразования из типа Dynamic в первоначальный тип
данных. Благодаря тому, что все преобразования реализованные в данной
библиотеки проверяют корректность типов, а конструктор типа Dynamic
является скрытым, у программиста нет возможности нарушить безопасность
типов. Таким образом функция readD в терминах типа Dynamic может быть
записана следующим образом:

\begin{code}
  readD :: StringTypeRepr -> StringDataRepr -> Dynamic
  readD t d = case t of
                "Integer" -> toDyn (read d :: Integer)
                "Double"  -> toDyn (read d :: Double)
\end{code}

Функция определённая таки образом выбирает тип данных во время
выполнения, но, к сожалению, такое решение также является монолитным,
поскольку не позволяет комбинировать функции для разбора данных из
разных модулей. Таким образом программист, создающий новый модуль для
системы должен знать в каком модуле объявлена функция разбирающая все
типы наиболее полно и вызывать эту функцию в качестве решения по
умолчанию:

\begin{code}
  readD t d = case t of
                "Integer" -> toDyn (read d :: Integer)
                ...
                _  -> Module.readD t d
\end{code}

Для того чтобы решить эту проблему необходимо в качестве результата
возвращать значение, согнализирующее о том, смогли ли мы разобрать
переданные данные. С таким условием функция readD будет иметь
следующее определенеие

\begin{code}
  readD :: StringTypeRepr -> StringDataRepr -> Maybe Dynamic
  readD t d = case t of
                "Integer" -> Just (toDyn (read d :: Integer))
                ...
                _  -> Nothing
\end{code}

В таком случае мы можем определить комбинатор, который объединяет две
реализации в одну

\begin{code}
  combine read1 read2 t d = case read1 t d of
                              Nothing -> read2 t d
                              result  -> result
\end{code}

Это решение справляется со всеми проблемами указанными выше: Оно не
является монолитным и оно включает в себя проверки безопасности типов
при использовании unsafe операций. Рассмотрим как при использовании
такого решения будут выглядеть типы динамических функций

\begin{code}
  func :: Dynamic -> Dynamic -> Maybe Dynamic
\end{code}

Так как данные функции создаются для использования при взаимодействии
со внешней средой, то нам необходима таблица функций, указывающая
соответствие между полученными текстовыми данными и выбираемой
функцией

\begin{code}
  symbolTable :: [(String, Dynamic -> Dynamic -> Maybe Dynamic)]
\end{code}

Как видно из данного определения при использовании так определённых
динамических функций нам придётся иметь по таблице символов для
функций каждой арности. И если в каком-то модуле появятся функции
неучтённой арности, то разработчику модуля придётся изменять код ядра
системы с целью добавления таблицы символов для функций новой
арности. К счастью данный недостаток легко устранив переписав
определение функции в виде

\begin{code}
  func :: [Dynamic] -> Maybe Dynamic
\end{code}

И используя единую таблицу функций

\begin{code}
  symbolTable :: [(String, Dynamic -> Dynamic -> Maybe Dynamic)]
\end{code}

Кроме таблицы символов такой системе потребуется таблица типов

\begin{code}
  readTable :: [(String, String -> Maybe Dynamic)]
\end{code}

Кажду функцию данной таблицы можно определить через описанную выше
функцию readD

\begin{code}
  readTable = [("Type1", readD "Type1"), ... ("TypeN", readD "TypeN")]
\end{code}

Также системе необходима таблица функций для вывода данных

\begin{code}
  showTable :: [(TypeRep, Dynamic -> Maybe String)]
\end{code}
