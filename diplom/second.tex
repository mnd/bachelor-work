% -*- mode: LaTeX; mode: auto-fill; mode: flyspell; coding: koi8-r; -*-
\chapter{Существующие решения}

Задачи, связанные с обработкой данных большого числа разных
типов, встречаются достаточно часто и для упрощения работы над этими
задачами были созданы различные библиотеки. Далее будут рассмотрены
существующие решения таких задач.

\section{Template Haskell}

Template Haskell\cite{th1} создан как, гарантирующее безопасность типов,
расширение языка Haskell. Данное расширение позволяет оперировать с
конструкциями корректными в языке Haskell на уровне абстрактных
синтаксических деревьев.

При помощи Template Haskell возможно создание функций генерирующих код
во время компиляции. Так мы можем определить функции
\begin{code}
$(zipN 3)
$(deriveShow ''Maybe)
\end{code}
Которые будут генерировать следующий код:
\begin{code}
let zip = \ y1 y2 y3 ->
  case (y1, y2, y3) of
    (x1:xs1, x2:xs2, x3:xs3) -> (x1, x2, x3) : zip xs1 xs2 xs3
    (_, _, _) -> []
in zip

instance Show (Maybe a) where
  show (Just a) = "Just" ++ show a
  show (Nothing) = "Nothing"
\end{code}

К сожалению, так как данное расширение работает, также как и сам
Haskell, в рамках функциональной парадигмы программирования, то внутри
функции генерирующей тип DataUnit невозможно узнать информацию о типах
данных определенных в различных модулях системы.

\section{Generic Haskell}

Рассмотрим следующую задачу: Существует завод, структуры которого
можно определить как
\begin{code}
data Factory  = Factory Director [Worker] [Builing]
data Director = Director Name Salary
data Worker   = Worker Name Salary
data Salary   = Salary Double
data Building = ...
\end{code}

Необходимо провести плановое увеличение зарплаты всех работников на
10\%. Опишем функции решающие задачу

\begin{code}
incF p (Factory d ws bs) = Factory (incD p d) (map (incW p) ws) bs
incD p (Director n s) = Director n (incS p s)
incW p (Worker n s)   = Worker n (incS p s)
incS p (Salary s)     = Salary ((1 + d) * s)
\end{code}

Имея такие функции мы сможем увеличить зарплату всех сотрудников на
10\% вызвав функцию
\begin{code}
incF 0.1 factory
\end{code}

Проблема данного решения в существовании большого количества функций,
которые не делают ничего, кроме обхода структур. Для того чтобы решить
данную проблемы были созданы Generic Haskell библиотеки. При
использовании одной из таких библиотек мы сможем увеличить зарплату
всем сотрудникам при помощи функции
\begin{code}
everywhere (mkT $ incS p) factory
\end{code} %$
доверив создание логики обхода данных библиотечной функции.

Различные Generic Haskell библиотеки генерируют функции обхода данных
либо при помощи Template Haskell, либо при помощи внешних генераторов
кода, либо создавая расширение для компилятора\cite{gen}.

Кроме этого некоторые библиотеки для обобщенного программирования,
такие как SYB\cite{syb}, имеют интерфейсы для создания обощённых функций. В
качестве примера рассмотрим написанный выше код:
\begin{code}
mkT $ incS p
\end{code} %$
Этот код возвращает полиморфную функцию, которая для данных всех
типов, кроме Salary, возвращает переданное значение, а для типа Salary
возвращает результат применения функции (incS p)

Это достигается следующим образом: В язык добавляется генерация
идентификатора типа

\begin{code}
data TypeRep = TypeRep Key TyCon [TypeRep]
data Key = Key Int
\end{code}

Для каждого существующего типа данных выбирается уникальный ключ. Имея
такое представление типов для создания полиморфной функции достаточно
проверить соответствует ли тип результата типу переданной функции. В
случае если типы соответствует, то остается, при помощи функции
unsafeCoerce, обойти проверку типов, работающую во время
компиляции. Иначе вернуть полиморфную функцию id.

\begin{code}
mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a
mkT f = case cast f of
          Just g  -> g
          Nothing -> id

cast :: (Typeable a, Typeable b) => a -> Maybe b
cast x = r
  where
    r = if typeOf x == typeOf (fromJust r)
          then Just $ unsafeCoerce x
          else Nothing
\end{code} %$

Таким образом осуществляется проверка корректности типа переданного
аргумента во время выполнения, а не во время компиляции.

Данный подход позволяет реализовать функцию gread\cite{syb2} умеющую разбирать
несколько типов данных

\begin{code}
gread :: StringTypeRepr -> StringDataRepr -> a
\end{code}

Такую функцию можно использовать следующим образом

\begin{code}
gread integerID data :: Integer
gread doubleID  data :: Double
\end{code}

Как видно из этого примера у данного решения существует фатальный
недостаток: для его использования необходимо знать данные каких типов
и в каком порядке будут переданны системе во время работы.

Таким образом использовать generic библиотеки для создания
рассматриваемых систем невозможно.

\section{Data.Dynamic}

Dynamic типы распространяемые в комплекте с компилятором GHC
представляют из себя пару
\begin{code}
data Dynamic = Dynamic TypeRep Data
\end{code}
которая является типом данных предложенным в первой главе. Кроме
самого типа библиотека Data.Dynamic предоставляет интерфейсы для
преобразования данных произвольного типа в тип Dynamic и для
преобразования из типа Dynamic в первоначальный тип данных. Благодаря
тому, что все преобразования реализованные в данной библиотеке
проверяют корректность типов, а конструктор типа Dynamic является
скрытым, у программиста нет возможности нарушить безопасность
типов. Таким образом функция readD в терминах типа Dynamic может быть
записана следующим образом:
\begin{code}
readD :: StringTypeRepr -> StringDataRepr -> Dynamic
readD t d = case t of
              "Integer" -> toDyn (read d :: Integer)
              "Double"  -> toDyn (read d :: Double)
\end{code}

Функция определённая таким образом выбирает тип данных во время
выполнения, но, к сожалению, такое решение также является монолитным,
поскольку не позволяет комбинировать функции для разбора данных из
разных модулей. Таким образом программист, создающий новый модуль для
системы должен знать в каком модуле объявлена функция разбирающая все
типы наиболее полно и вызывать эту функцию в качестве решения по
умолчанию:

\begin{code}
readD t d = case t of
              "Integer" -> toDyn (read d :: Integer)
              ...
              _ -> Module.readD t d
\end{code}

Для того чтобы решить эту проблему необходимо в качестве результата
возвращать значение, сигнализирующее о том, смогли ли мы разобрать
переданные данные. С таким условием функция readD будет иметь
следующее определение

\begin{code}
readD :: StringTypeRepr -> StringDataRepr -> Maybe Dynamic
readD t d = case t of
              "Integer" -> Just (toDyn (read d :: Integer))
              ...
              _  -> Nothing
\end{code}

В таком случае мы сможем определить комбинатор, который объединяет две
реализации в одну

\begin{code}
combine read1 read2 t d = case read1 t d of
                            Nothing -> read2 t d
                            result  -> result
\end{code}

Это решение справляется со всеми проблемами указанными выше: Оно не
является монолитным и оно включает в себя проверки безопасности типов
при использовании unsafe операций. Рассмотрим как при использовании
такого решения будут выглядеть типы динамических функций

\begin{code}
func1 :: Dynamic -> Maybe Dynamic
func2 :: Dynamic -> Dynamic -> Maybe Dynamic
func3 :: Dynamic -> Dynamic -> Dynamic -> Maybe Dynamic
\end{code}

Так как данные функции создаются для использования при взаимодействии
со внешней средой, то нам необходима таблица функций, указывающая
соответствие между полученными текстовыми данными и выбираемой
функцией

\begin{code}
symbolTable :: [(String, Dynamic -> Dynamic -> Maybe Dynamic)]
\end{code}

Как видно из данного определения, при использовании так определённых
динамических функций нам придётся иметь по таблице символов для
функций каждой арности. И если в каком-то модуле появятся функции
неучтённой арности, то разработчику модуля придётся изменять код ядра
системы с целью добавления таблицы символов для функций новой
арности. К счастью данный недостаток легко устранить переписав
определение функции в виде
\begin{code}
func :: [Dynamic] -> Maybe Dynamic
\end{code}
И используя единую таблицу функций
\begin{code}
symbolTable :: [(String, Dynamic -> Dynamic -> Maybe Dynamic)]
\end{code}

Кроме таблицы символов такой системе потребуется таблица типов
\begin{code}
readTable :: [(String, String -> Maybe Dynamic)]
\end{code}

Каждую функцию данной таблицы можно определить через описанную выше
функцию readD:
\begin{code}
readTable = [("Type1", readD "Type1"), ... ("TypeN", readD "TypeN")]
\end{code}

Также системе необходима таблица функций для вывода данных:
\begin{code}
showTable :: [(TypeRep, Dynamic -> Maybe String)]
\end{code}
